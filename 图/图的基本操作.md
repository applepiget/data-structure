## 图的基本操作

![图的基本操作](D:\笔记\数据结构\思维导图\图的基本操作.png)

**Adjacent(G , x , y)**

1. 无向图：
   1. 邻接矩阵：判断两个顶点所对应的矩阵中的值是否等于1，时间复杂度O(1)
   2. 邻接表：遍历以该顶点为表头的链表，时间复杂度O(1) - O(|V|)

2. 有向图：与无向图的思路一致



**Neighbors(G , x)**

1. 无向图：
   1. 邻接矩阵：遍历该顶点在矩阵中所对应的行，时间复杂度O(|V|)
   2. 邻接表：遍历以该顶点为表头的链表，时间复杂度O(1) - O(|V|)

2. 有向图：
   1. 邻接矩阵：遍历该顶点在矩阵中所对应的行 / 列，对应该顶点的出边 / 入边，时间复杂度O(|V|)
   2. 邻接表：寻找出边，遍历以该顶点为表头的链表，时间复杂度O(1) - O(|V|)；寻找入边，遍历整个邻接表，时间复杂度O(|E|)



**InsertVex(G , x)**

1. 无向图：
   1. 邻接矩阵：在存储顶点的数组中加入新的顶点，时间复杂度O(1)
   2. 邻接链表：在存储顶点的数组中加入新的顶点，指针设为NULL，时间复杂度O(1)

2. 有向图：与无相图的思路一致



**DeleteVex(G , x)**

1. 无向图：
   1. 邻接矩阵：可以将该顶点在矩阵中对应的行、列都设为0，平设置一个bool变量，表示顶点为空，时间复杂第O(|V|)
   2. 邻接表：遍历邻接表，讲所有与该顶点有关的边全不删除，时间复杂度O(1) - O(|E|)

2. 有向图：
   1. 邻接矩阵：与无向图的思路一致
   2. 邻接表：删除出边，只需要遍历该顶点对应的链表，并删除，时间复杂度O(1) - O(|V|)；删除入边，需要遍历整个邻接表O(|E|)



**AddEdge(G , x , y)**

1. 无向图：
   1. 邻接矩阵：在矩阵中对应两个顶点的位置，将该位置上的值修改为1，时间复杂度O(1)
   2. 邻接表：遍历两个顶点的边链表，插入结点（可以使用头插法，时间复杂度O(1)）

2. 有向图：思路与无向图基本一致



**FirstNeighbor(G , x)**

1. 无向图：
   1. 邻接矩阵：遍历该顶点在矩阵种所对应行，找到第一个值为1的点，时间复杂度O(1) - O(|V|)
   2. 邻接表：直接找到该顶点的边链表的第一个节点，时间复杂度O(1)

2. 有向图：
   1. 邻接矩阵：找出边，遍历对应的矩阵的行；找入边，遍历对应的矩阵的列，时间复杂度O(1) - O(|V|)
   2. 邻接表：找出边，直接找到该顶点的边链表的第一个节点，时间复杂度O(1)；找入边，遍历整个邻接表，时间复杂度O(1) - O(|E|)



**NextNeighbor(G , x , y)**

1. 无向图：
   1. 邻接矩阵：在 x 对应的行中找到矩阵中 y 结点之后的第一个值为1的点，时间复杂度O(1) - O(|V|)
   2. 邻接表：直接返回该顶点所对应的边链表中的第二个结点，时间复杂度O(1)